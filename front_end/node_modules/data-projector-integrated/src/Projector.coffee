# Projector.coffee
# Tomasz (Tomek) Zemla
# tomek@datacratic.com

# Projector class displays the data visualization.
# Images are rendered in WebGL on HTML5 Canvas using Three.js library.

# TODO Extend selection to work in ORTHOGRAPHIC and PERSPECTIVE, not only DUAL mode.

THREE = require('three')
TWEEN = require('tween.js')
Detector = require('cvdlab-three-detector')
TrackballControls = require('three.trackball')

Subject = require('./Subject.js')
Utility = require('./Utility.js')
Palette = require('./Palette.js')
Selector = require('./Selector.js')

class Projector extends Subject

   # E V E N T S

   @EVENT_DATA_LOADED : "EVENT_DATA_LOADED"
   @EVENT_POINTS_SELECTED : "EVENT_POINTS_SELECTED"
   @EVENT_CLUSTER_SELECTED : "EVENT_CLUSTER_SELECTED"

   # C O N S T A N T S

   # three view/display modes
   @VIEW : { NONE: -1, PERSPECTIVE: 0, ORTHOGRAPHIC: 1, DUAL: 2 }

   # spin clock or counter clockwise
   @SPIN : { LEFT: -1, NONE: 0, RIGHT: +1 }

   @SPIN_STEP : Utility.DEGREE / 10 # 0.1 degree - default step

   # M E M B E R S

   # these are pseudo constants which are redefined when browser resizes
   SCREEN_WIDTH : $("#container").width()
   SCREEN_HEIGHT : $("#container").height()

   mode : Projector.VIEW.PERSPECTIVE # starting default

   storage : null # reference to the data storage

   colors : null # Array<THREE.Color> generated color values for visualization

   scene : null # THREE.Scene

   delta : null # time delta

   # perspective (3D) and orthographic (2D) projection cameras

   cameraPerspective : null # THREE.PerspectiveCamera
   cameraOrthographic : null # THREE.OrthographicCamera

   renderer : null # THREE.WebGLRenderer

   # mouse tracking variables
   mouse : new THREE.Vector3() # current mouse coordinates when selecting
   mouseStart : new THREE.Vector3() # mouse down coordinates when selecting
   mouseEnd : new THREE.Vector3() # mouse up coordinates when selecting
   dragging : false # true when rubber banding...

   selector : null # Selector

   # visual helpers for data display
   box : null # THREE.Mesh - data cage  
   bound : null # THREE.Mesh - data bounds
   axes : null # THREE.Mesh - central axes
   viewport : null # parent of selectable view rectangles
   direction : Utility.DIRECTION.TOP # default 2D view is from top
   view1 : null # THREE.Line - 2D orthographic view box - top
   view2 : null # THREE.Line - 2D orthographic view box - front
   view3 : null # THREE.Line - 2D orthographic view box - side

   # visual representations of loaded data
   points : null # Array<THREE.Geometry>
   particles : null # Array<THREE.ParticleSystem>
   clusters : null # array of particle systems one per cluster

   dimensionSize : 500 # how big our space is, should be a multiple of 2
   minDimensionSize: 100

   orthDistance: 350

   minDraw: 70
   maxDraw: 1500

   maxX : null
   maxY : null
   maxZ : null

   xNormalization: null
   yNormalization: null
   zNormalization: null

   selected : -1 # currently selected cluster

   controls : null # THREE.TrackballControls

   timeStamp : 0

   # C O N S T R U C T O R

   # Create projector.
   # Constructor creates all initial setup to make projector ready for data.
   constructor: ->

      super()

      @addUIListeners() # listen for UI events

      @scene = new THREE.Scene() # 3D world

      @createPerspectiveCamera() # left side (dual mode): 3D perspective camera
      @createOrthographicCamera() # right side (dual mode): 2D ortographic projection camera

      @createControls() # trackball simulation controls

      @createBox() # bounding box for the data
      @createBound()
      @createAxes()

      @cameraPerspective.lookAt( @box.position )
      @cameraOrthographic.lookAt( @box.position )

      @createViews()
      @updateView(true)

      @selector = new Selector(@box) # 3D rubber band selector

      @createRenderingEngine() # set up WebGL renderer on canvas

      @onWindowResize(null)

      @animate() # start rendering loop!


   # E V E N T   H A N D L E R S

   # Make updates related to window size changes.
   # Also used when view configuration is switched.
   onWindowResize : (event) =>

      @SCREEN_WIDTH = $("#container").width()
      @SCREEN_HEIGHT = $("#container").height()

      console.log "Screen #{@SCREEN_WIDTH} x #{@SCREEN_HEIGHT}"

      if @renderer?

         @renderer.setSize( @SCREEN_WIDTH, @SCREEN_HEIGHT )

         switch @mode

            when Projector.VIEW.PERSPECTIVE
               @cameraPerspective.aspect = @SCREEN_WIDTH / @SCREEN_HEIGHT
               @cameraPerspective.updateProjectionMatrix()

            when Projector.VIEW.ORTHOGRAPHIC
               @cameraOrthographic.left   = - (@SCREEN_WIDTH / 3)
               @cameraOrthographic.right  = + (@SCREEN_WIDTH / 3)
               @cameraOrthographic.top    = + (@SCREEN_HEIGHT / 3)
               @cameraOrthographic.bottom = - (@SCREEN_HEIGHT / 3)
               @cameraOrthographic.updateProjectionMatrix()

            when Projector.VIEW.DUAL
               # left side
               @cameraPerspective.aspect = 0.5 * @SCREEN_WIDTH / @SCREEN_HEIGHT
               @cameraPerspective.updateProjectionMatrix()
               # right side
               @cameraOrthographic.left   = - (@SCREEN_WIDTH / 10)
               @cameraOrthographic.right  = + (@SCREEN_WIDTH / 10)
               @cameraOrthographic.top    = + (@SCREEN_HEIGHT / 5)
               @cameraOrthographic.bottom = - (@SCREEN_HEIGHT / 5)
               @cameraOrthographic.updateProjectionMatrix()

      @controls.handleResize()


   onMouseDown : (event) =>

      if @mode is Projector.VIEW.DUAL

         event.preventDefault()

         if event.shiftKey

            @dragging = true
            @updateMouse3D()
            @mouseStart.copy(@mouse)
            @selector.start(@mouseStart.clone())
            
            event.stopPropagation()


   onMouseMove : (event) =>

      if @mode is Projector.VIEW.DUAL

         event.preventDefault()

         if @dragging

            @updateMouse3D()
            @selector.update(@mouse)

            event.stopPropagation()


   onMouseUp : (event) =>

      if @mode is Projector.VIEW.DUAL

         event.preventDefault()

         if @dragging

            @dragging = false
            @updateMouse3D()
            @mouseEnd.copy(@mouse)
            @selector.end(@mouseEnd.clone())
            @updateSelection()

            event.stopPropagation()


   # Toggle next cluster during the animated walk through.
   onTimer : (index) =>

      if @animateOn
          @toggleClusterVisibility(index)
          if ++index is @storage.getClusters() then index = 0
          @startTimer(index)


   # M E T H O D S

   # Set the current mode.
   setMode : (@mode) =>

      @onWindowResize(null)


   # Use given color set for visualization.
   setColors : (@colors) =>


   # Toggle box visibility. Return current state.
   toggleBox : => return (@bound.visible = not @bound.visible)


   # Toggle viewport visibility. Return current state.
   toggleViewport : => return @updateView(not @viewport.visible)


   toggleSelector : =>
   
      state = @selector.toggle()
      @updateSelection()
      return state


   # Get the base 64 encoded image of the current state of the projector.
   getImage : =>

      return document.getElementById("renderer").toDataURL("image/png")


   # Hook up to browser and mouse events.
   addUIListeners : =>

      window.addEventListener('resize', @onWindowResize, false)

      # container will hold WebGL canvas

      $('#container').mousedown(@onMouseDown)
      $('#container').mousemove(@onMouseMove)
      $('#container').mouseup(@onMouseUp)


   # Proper 3D camera.
   createPerspectiveCamera : =>

      # NOTE Cameras aspect ratio setup matches the half screen viewports for initial dual mode

      @cameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * @SCREEN_WIDTH / @SCREEN_HEIGHT, @minDraw, @maxDraw )
      @cameraPerspective.position.set(0, 0, 550)
      @scene.add( @cameraPerspective )


   # Flat, 2D, no perspective camera.
   createOrthographicCamera : =>

      @cameraOrthographic = new THREE.OrthographicCamera( - (@dimensionSize * 1.2),
                                                          + (@dimensionSize * 1.2),
                                                          + (@dimensionSize * 1.2),
                                                          - (@dimensionSize * 1.2),
                                                          @minDraw, @maxDraw )
      @cameraOrthographic.position.set(0, 600, 0)
      @scene.add( @cameraOrthographic )


   # Initialize simulated trackball navigation controls
   createControls : =>

      @controls = new TrackballControls( @cameraPerspective, $("#container").get(0) )

      @controls.rotateSpeed = 1.0
      @controls.zoomSpeed = 1.0
      @controls.panSpeed = 0.8

      @controls.noZoom = false
      @controls.noPan = false

      @controls.staticMoving = true
      @controls.dynamicDampingFactor = 0.3

      @controls.addEventListener('change', @render)


   # Bounding box where the data is displayed.
   createBox : =>
       @box = new THREE.Mesh()
       @scene.add(@box)
   
   createBound : =>

      boundMesh = new THREE.Mesh(new THREE.BoxGeometry(@dimensionSize, @dimensionSize, @dimensionSize))
      @bound = new THREE.BoxHelper( boundMesh )
      @bound.material.color.set( Palette.AXES.getHex() )
      @bound.visible = false;
      @scene.add(@bound)

    createAxes : =>

      axisMat = new THREE.LineBasicMaterial({ color: Palette.AXES.getHex() })

      hds = @dimensionSize / 2

      xGeo = new THREE.Geometry()
      xGeo.vertices.push(new THREE.Vector3(-hds, 0 ,0))
      xGeo.vertices.push(new THREE.Vector3(+hds, 0 ,0))
      xAxis = new THREE.Line( xGeo, axisMat )
      
      yGeo = new THREE.Geometry()
      yGeo.vertices.push(new THREE.Vector3(0, -hds, 0))
      yGeo.vertices.push(new THREE.Vector3(0, +hds, 0))
      yAxis = new THREE.Line( yGeo, axisMat )

      zGeo = new THREE.Geometry()
      zGeo.vertices.push(new THREE.Vector3(0, 0, -hds))
      zGeo.vertices.push(new THREE.Vector3(0, 0, +hds)) 
      zAxis = new THREE.Line( zGeo, axisMat )

      xAxis.visible = false;
      yAxis.visible = false;
      zAxis.visible = false;

      @scene.add(xAxis)
      @scene.add(yAxis)
      @scene.add(zAxis)


   # Create a set of highlights that indicate ortographic projection in perspective view.
   # Each rectangle simply indicates where 2D view is within the 3D space.
   createViews : =>

      @viewport = new THREE.Object3D()

      # half our dimension size
      hds = @dimensionSize / 2
      lineMat = new THREE.LineBasicMaterial()

      # top view
      geometry1 = new THREE.Geometry()
      geometry1.vertices.push( new THREE.Vector3( +hds, +hds+1, +hds ) )
      geometry1.vertices.push( new THREE.Vector3( -hds, +hds+1, +hds ) )
      geometry1.vertices.push( new THREE.Vector3( -hds, +hds+1, -hds ) )
      geometry1.vertices.push( new THREE.Vector3( +hds, +hds+1, -hds ) )
      geometry1.vertices.push( new THREE.Vector3( +hds, +hds+1, +hds ) )

      @view1 = new THREE.Line(geometry1, lineMat, THREE.LineStrip)

      # front view
      geometry2 = new THREE.Geometry()
      geometry2.vertices.push( new THREE.Vector3( +hds, +hds, +hds+1 ) )
      geometry2.vertices.push( new THREE.Vector3( -hds, +hds, +hds+1 ) )
      geometry2.vertices.push( new THREE.Vector3( -hds, -hds, +hds+1 ) )
      geometry2.vertices.push( new THREE.Vector3( +hds, -hds, +hds+1 ) )
      geometry2.vertices.push( new THREE.Vector3( +hds, +hds, +hds+1 ) )

      @view2 = new THREE.Line(geometry2, lineMat, THREE.LineStrip)

      # side view
      geometry3 = new THREE.Geometry()
      geometry3.vertices.push( new THREE.Vector3( +hds+1, +hds, +hds ) )
      geometry3.vertices.push( new THREE.Vector3( +hds+1, -hds, +hds ) )
      geometry3.vertices.push( new THREE.Vector3( +hds+1, -hds, -hds ) )
      geometry3.vertices.push( new THREE.Vector3( +hds+1, +hds, -hds ) )
      geometry3.vertices.push( new THREE.Vector3( +hds+1, +hds, +hds ) )

      @view3 = new THREE.Line(geometry3, lineMat, THREE.LineStrip)

      @view1.visible = false;
      @view2.visible = false;
      @view3.visible = false;

      @viewport.add(@view1) # top
      @viewport.add(@view2) # front
      @viewport.add(@view3) # side

      @viewport.visible = false;

      @box.add(@viewport)


   createRenderingEngine : =>

      # basically canvas in WebGL mode
      if Detector.webgl
        @renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } )
        $('#no-webgl-modal').hide()
      else
        @renderer = new THREE.CanvasRenderer()
        $('#no-webgl-modal').show()
        #@renderer = new THREE.CanvasRenderer( { antialias: true, preserveDrawingBuffer: true } )
      console.log(@renderer)
      @renderer.setSize( @SCREEN_WIDTH, @SCREEN_HEIGHT )
      @renderer.setClearColor( Palette.BACKGROUND.getHex(), 1 )
      @renderer.domElement.style.position = "relative"
      @renderer.domElement.id = "renderer"
      @renderer.autoClear = false

      # container is the display area placeholder in HTML
      container = $('#container').get(0)
      container.appendChild( @renderer.domElement )


   # Load JSON data to visualize.
   load : (@storage) =>

      data = @storage.getData() # JSON
      clusters = @storage.getClusters() # number of clusters

      # create point clouds first for each cluster

      @points = new Array()

      for c in [0...clusters]
         @points[c] = new THREE.Geometry()
         @points[c].colorsNeedUpdate = true

      @calcNormalization(data.points)

      # process JSON data
      $.each(data.points, @processPoint)

      # create particle systems for each cluster (with point clouds within)

      @particles = new Array()

      if(@renderer instanceof THREE.WebGLRenderer)
         for p in [0...clusters]
            material = new THREE.PointCloudMaterial( { size: 3.5, sizeAttenuation: true, vertexColors: true } )
            @particles[p] = new THREE.PointCloud( @points[p], material )
            @scene.add( @particles[p] ) # put them in the data cage

      unused_canvas_rendering = """
      geometry = new THREE.Geometry()
      material = new THREE.MeshBasicMaterial()
      for p in [0...data.points.length]
         position = new THREE.Vector3(data.points[p].x,
                                      data.points[p].y,
                                      data.points[p].z)
         box = new THREE.BoxGeometry(1,1,1)
         mesh = new THREE.Mesh(box)
         mesh.position.copy(position)
         mesh.updateMatrix()
         geometry.merge(mesh.geometry, mesh.matrix)

      mesh = new THREE.Mesh(geometry, material)
      @scene.add(mesh)
      """

      unused_canvas_rendering_2 = """
         console.log("SpriteCanvasMaterial")
         canvas = document.createElement("canvas")
         canvas.width = canvas.height = 10
         ctx = canvas.getContext('2d')
         ctx.beginPath()
         ctx.rect(0,0, canvas.width, canvas.height)
         ctx.fillStyle = '#ffffff'
         ctx.fill()
         texture = new THREE.Texture(canvas)
         texture = THREE.ImageUtils.loadTexture( 'point.png' )
         material = new THREE.PointCloudMaterial( { transparent: true, size: 40, map: texture, depthTest: true } )
         material.color.setHSL( 0.9,0.2,0.2 );

         geometry = new THREE.Geometry()
         console.log(texture, geometry, material)
         for p in [0...data.points.length]
             position = new THREE.Vector3(data.points[p].x,
                                          data.points[p].y,
                                          data.points[p].z)
             geometry.vertices.push(position.clone())
         pointCloud = new THREE.PointCloud( geometry, material )
         @scene.add( pointCloud )
      """


      @notify(Projector.EVENT_DATA_LOADED)


   calcNormalization : (points) =>

       hds = @dimensionSize / 2

       pointCount = points.length
       maxAbsX = maxAbsY = maxAbsZ = 0

       for p in [0...pointCount]
           maxAbsX = Math.max(Math.abs(points[p].x), maxAbsX)
           maxAbsY = Math.max(Math.abs(points[p].y), maxAbsY)
           maxAbsZ = Math.max(Math.abs(points[p].z), maxAbsZ)

       @maxX = maxAbsX
       @maxY = maxAbsY
       @maxZ = maxAbsZ

       @xNormalization = hds / @maxX
       @yNormalization = hds / @maxY
       @zNormalization = hds / @maxZ


   # Called for each data point loaded in JSON file.
   processPoint : (nodeName, nodeData) =>

      # cluster index
      index = @storage.getCidIndex(nodeData.cid)

      vertex = new THREE.Vector3()
      vertex.x = parseFloat( nodeData.x * @xNormalization )
      vertex.y = parseFloat( nodeData.y * @yNormalization )
      vertex.z = parseFloat( nodeData.z * @zNormalization )
      
      @points[index].vertices.push( vertex )

      # NOTE Although initially all points in the same cluster have the same color
      # they do take individual colors during the selection interactions therefore
      # each point needs its own individual color object instead of shared one...

      color = @colors[index].clone()
      @points[index].colors.push( color )


   # Rendering loop - animate calls itself forever.
   animate : (time) =>

      requestAnimationFrame( @animate )
      @controls.update()
      TWEEN.update(time)
      @render()


   # Rendering done on each frame.
   # Rendering configuration depends on the current view mode.
   render : =>

      @renderer.clear()

      switch @mode

         # one viewport: perspective camera only
         when Projector.VIEW.PERSPECTIVE
            if @spin isnt Projector.SPIN.NONE then @spinCamera()
            @cameraPerspective.lookAt( @box.position )
            # RENDERING
            @renderer.setViewport( 0, 0, @SCREEN_WIDTH, @SCREEN_HEIGHT )
            @renderer.render( @scene, @cameraPerspective )

         # one viewport: orthographic camera only
         when Projector.VIEW.ORTHOGRAPHIC
            # RENDERING
            @cameraOrthographic.rotation.z = 0
            @renderer.setViewport( 0, 0, @SCREEN_WIDTH, @SCREEN_HEIGHT )
            @renderer.render( @scene, @cameraOrthographic )

         # dual perspective and orthographic cameras view
         when Projector.VIEW.DUAL
            # synchronize camera with rotation
            if @spin isnt Projector.SPIN.NONE then @spinCamera()
            @cameraPerspective.lookAt( @box.position )
            # RENDERING
            # left side viewport: perspective camera
            @renderer.setViewport( 0, 0, @SCREEN_WIDTH/2, @SCREEN_HEIGHT )
            @renderer.render( @scene, @cameraPerspective )
            # right side viewport: orthographic camera
            @cameraOrthographic.rotation.z = 0
            @renderer.setViewport( @SCREEN_WIDTH/2, 0, @SCREEN_WIDTH/2, @SCREEN_HEIGHT )
            @renderer.render( @scene, @cameraOrthographic )


   updateSelection : =>

      # algorithm:
      # loop through all clusters
      # if cluster is visible then process it
      # for each point check if it's inside selection
      # if inside (and selector is active) set color to highlight
      # else set color to original cluster color

      counter = 0

      for i in [0...@storage.getClusters()]
         if @particles[i].visible
            cloud = @points[i]
            all = cloud.vertices.length
            for j in [0...all]
               vertex = cloud.vertices[j]
               color = cloud.colors[j]
               if @selector.isActive() and @selector.contains(vertex, Utility.DIRECTION.ALL) 
                  color.setHex(Palette.HIGHLIGHT.getHex())
                  counter++
                  # Utility.printVector3(vertex)
               else
                  color.setHex(@colors[i].getHex())

            cloud.colorsNeedUpdate = true;

      @notify(Projector.EVENT_POINTS_SELECTED, { points : counter })


   updateMouse3D : =>

      # NOTE This works only in DUAL mode
      # TODO Extend this to other modes

      ratio = 100 / 250 # ?

      switch @direction
         when Utility.DIRECTION.TOP
            @mouse.x = (event.pageX - (3 * @SCREEN_WIDTH / 4)) * ratio
            @mouse.y = 100
            @mouse.z = (event.pageY - (@SCREEN_HEIGHT / 2)) * ratio
         when Utility.DIRECTION.FRONT
            @mouse.x = (event.pageX - (3 * @SCREEN_WIDTH / 4)) * ratio
            @mouse.y = - (event.pageY - (@SCREEN_HEIGHT / 2)) * ratio
            @mouse.z = 100
         when Utility.DIRECTION.SIDE
            @mouse.x = 100
            @mouse.y = - (event.pageY - (@SCREEN_HEIGHT / 2)) * ratio
            @mouse.z = - (event.pageX - (3 * @SCREEN_WIDTH / 4)) * ratio


   # Returns 3D camera to its starting orientation and optionally position.
   # Position is only reset if location argument is true.
   resetCamera : (location, up) =>

      if location then new TWEEN.Tween(@cameraPerspective.position).to(location, 1000).start()
      new TWEEN.Tween(@cameraPerspective.rotation).to({ x:0, y:0, z:0 }, 1000).start()
      up = up || {x:0.0, y:1.0, z:0.0}
      new TWEEN.Tween(@cameraPerspective.up).to(up, 1000).start()


   # Set the visibility of orthographic view (top, front, side) indicator.
   updateView : (visible) =>

      @viewport.visible = visible

      # NOTE Changing visibility of the viewport alone does not work as the change
      # of visibility of the parent is an ongoing bug/issue of the ThreeJS library...
      # ...so toggle all three separately
      
      orthDist = @dimensionSize * 1.2

      if @viewport.visible
         switch @direction
            when Utility.DIRECTION.TOP
               @setViewsVisible(false, false, false)
               #@setViewsVisible(true, false, false)
               @cameraOrthographic.position.set(0, orthDist, 0)
            when Utility.DIRECTION.FRONT
               @setViewsVisible(false, false, false)
               #@setViewsVisible(false, true, false)
               @cameraOrthographic.position.set(0, 0, orthDist)
            when Utility.DIRECTION.SIDE
               @setViewsVisible(false, false, false)
               #@setViewsVisible(false, false, true)
               @cameraOrthographic.position.set(orthDist, 0, 0)
         @cameraOrthographic.lookAt(@box.position)
      else
         @setViewsVisible(false, false, false)

      return @viewport.visible   


   # Set visibility of view indicators.
   setViewsVisible : (top, front, side) =>      

         @view1.visible = top
         @view2.visible = front
         @view3.visible = side


   changeView : (@direction) =>

      @updateView(@viewport.visible)
      @selector.setDirection(@direction)


   toggleAnimation : =>
   
      @animateOn = not @animateOn

      if @animateOn
         @setAllClustersVisible(false)
         @startTimer(0)
      else
         @setAllClustersVisible(true)

      return @animateOn   


   setSpin : (spin) =>

      if !@spin
          @spin = Projector.SPIN.NONE

      @spin = (@spin + 1) % 2

      switch @spin

        #when Projector.SPIN.LEFT
            #@resetCamera(false)

         when Projector.SPIN.NONE
            @timeStamp = 0

         when Projector.SPIN.RIGHT
            #@resetCamera(false)
            return @spin


   # Spin camera in a circle around the center.
   spinCamera : =>

       STEP = @getSpinStep()

       quat = new THREE.Quaternion()
       quat.setFromAxisAngle(@cameraPerspective.up, STEP)

       @cameraPerspective.position.applyQuaternion( quat )

   # Adjust the rotation step depending on time elapsed between the frames.
   getSpinStep : =>

      step = Projector.SPIN_STEP # default

      if @timeStamp isnt 0
         date = new Date()
         timeNow = date.getTime()
         delta = timeNow - @timeStamp
         @timeStamp = timeNow
         step = delta * step / 10

      return step


   # Toggle visibility of the cluster given by its index.
   toggleClusterVisibility : (index) =>

      @particles[index].visible = not @particles[index].visible


   setAllClustersVisible : (visible) =>

      p.visible = visible for p in @particles


   # Select or unselect cluster of given index.
   toggleClusterSelection : (index) =>

      # clear old selected
      if @selected > -1
         # restore color coding on previous selection
         hexColor = @colors[@selected].getHex()
         @updatePoints(@selected, hexColor)

      if @selected is index
         # unselecting
         @selected = -1
      else 
         # selecting
         @selected = index
         # highlight new selected
         @updatePoints(@selected, Palette.HIGHLIGHT.getHex())

      if @selected > -1
         @notify(Projector.EVENT_CLUSTER_SELECTED, { id : index })
      else 
         @notify(Projector.EVENT_CLUSTER_SELECTED, { id : -1 })


   # Color code given points cloud (cluster).
   updatePoints : (index, color) =>

      cloud = @points[index]
      all = cloud.vertices.length

      for i in [0...all]
         cloud.colors[i].setHex(color)

      @points[index].colorsNeedUpdate = true


   startTimer : (index) =>

      @toggleClusterVisibility(index)
      window.setTimeout(@onTimer, 2 * Utility.SECOND, index)


   # Count visible clusters.
   clustersVisible : =>

      result = 0

      result++ for cloud in @particles when cloud.visible

      return result


module.exports = Projector
